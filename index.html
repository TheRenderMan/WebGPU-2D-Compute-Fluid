<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Compute Fluid - 2d - WebGPU/WGSL</title>
<style>
  body { margin:0; overflow:hidden; background:#111; color:#ddd; font-family: monospace; }
  canvas { display:block; width:100vw; height:100vh; }
  #info { position: absolute; left:8px; top:8px; z-index:10; background:rgba(0,0,0,0.45); padding:6px 8px; border-radius:6px; font-size:13px; }
</style>
</head>
<body>
<div id="info">Starting...</div>
<canvas></canvas>
<script type="module">

    // AUTHOR: Leke Ayeko
    // PROJECT: WebGPU Fluid Simulation
    // LICENSE: MIT

    const infoEl = document.getElementById('info');
    const canvas = document.querySelector('canvas');

    // check if webgpu is supported
    if (!navigator.gpu) {
    document.body.innerText = 'WebGPU not supported';
    throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();

    // HiDPI canvas sizing
    function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    context.configure({
        device,
        format,
        alphaMode: 'opaque',
        size: [canvas.width, canvas.height]
    });
    }
    resize();
    window.addEventListener('resize', resize);

    // SIMULATION PARAMETERS 
    const particleCount = 5000;
    let dt = 0.006;                // time-step
    const gravity = [0.0, -3.8];   // gravity
    let dt_sqr = dt * dt;          // used in density relaxation
    let h = .22 * .22;             // neighbbor query radius
    let rho0 = .0000001;            // rest density
    let k = 13;                    // repulsion
    let k_near = 14;               // repulsion for near particles

    // Fixed-point scale for atomic accumulation (atomic<i32>)
    const SCALE = 100000.0; // tune for precision/overflow (1e5 is typical)

    const workgroupSize = 256;
    const dispatchCount = Math.ceil(particleCount / workgroupSize);

    // BUFFERS
    // particles: each particle uses 8 floats: x,y,vx,vy,pX,pY,pad0,pad1
    // since GPU bufffers requires memory size of multiple of 16, the buffer is padded
    const particleBuffer = device.createBuffer({
    label: 'particles',
    size: particleCount * 8 * Float32Array.BYTES_PER_ELEMENT,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });

    // displacement buffer: two atomic<i32> per particle (dx, dy)
    // this is needed because each particle thread(i) on the gpu has to displace nearby particles(j),
    // so to avoid race-conditions, a separate buffer is created to holds each particles displacement so
    // which would be applied on each particles in a separate compute pass
    const dispBuffer = device.createBuffer({
    label: 'displacements',
    size: particleCount * 2 * Int32Array.BYTES_PER_ELEMENT,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });

    // parameter buffer: 3 vec4 = 48 bytes (aligned)
    const paramsBuffer = device.createBuffer({
    label: 'params',
    size: 3 * 16,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // INITIALIZE DATA
    // particles init (x,y, vx,vy, pX,pY, pad0, pad1)
    {
    const data = new Float32Array(particleCount * 8);

    // pick grid dimensions
    const cols = Math.floor(Math.sqrt(particleCount));
    const rows = Math.ceil(particleCount / cols);
    const spacing = 0.02; // grid spacing
    const jitter = 0.01;  // small random offset

    let idx = 0;
    for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
        if (idx >= particleCount) break;

        const b = idx * 8;

        // center the block near (0,0)
        let x = (i - cols / 2) * spacing + (Math.random() - 0.5) * jitter;
        let y = (j - rows / 2) * spacing + (Math.random() - 0.5) * jitter - .1;

        data[b + 0] = x;   // pos.x
        data[b + 1] = y;   // pos.y
        data[b + 2] = 0.0; // vx
        data[b + 3] = 0.0; // vy
        data[b + 4] = x;   // previous pos.x
        data[b + 5] = y;   // previous pos.y
        data[b + 6] = 0.0; // padding
        data[b + 7] = 0.0;

        idx++;
        }
    }

    device.queue.writeBuffer(particleBuffer, 0, data);
    }


    // write an array of zeros into the displacement buffer
    {
    const zeros = new Int32Array(particleCount * 2);
    device.queue.writeBuffer(dispBuffer, 0, zeros);
    }

    // WRITE PARAMETERS
    function writeParams() {
    dt_sqr = dt * dt;
    // pack into 3 vec4s:
    // a: dt, gx, gy, dt_sqr
    // b: h, rho0, k, k_near
    // c: count (as float), SCALE, 0, 0
    const arr = new Float32Array([
        dt, gravity[0], gravity[1], dt_sqr,
        h, rho0, k, k_near,
        particleCount, SCALE, 0.0, 0.0
    ]);
    device.queue.writeBuffer(paramsBuffer, 0, arr);
    }
    writeParams();

    // WGSL COMPUTE SHADERS

    // pass 0: apply external forces (gravity for now)
    const applyExtForceWGSL = `
      struct Params {
      a : vec4<f32>, // a.x=dt, a.y=gx, a.z=gy, a.w=dt_sqr
      b : vec4<f32>, // b.x=h, b.y=rho0, b.z=k, b.w=k_near
      c : vec4<f32>, // c.x=count, c.y=SCALE
      };
  
      @group(0) @binding(0) var<uniform> params : Params;
  
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read_write> particles : array<Particle>;
  
      @compute @workgroup_size(${workgroupSize})
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
      let dt = params.a.x;
      let gy = params.a.z;
      particles[i].vy = particles[i].vy + gy * dt;
      }
    `;

    // pass 1: predict particles position
    const predPosWGSL = `
      struct Params { a : vec4<f32>, b : vec4<f32>, c : vec4<f32> };
      @group(0) @binding(0) var<uniform> params : Params;
  
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read_write> particles : array<Particle>;
  
      @compute @workgroup_size(${workgroupSize})
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
      let dt = params.a.x;
      particles[i].pX = particles[i].x;
      particles[i].pY = particles[i].y;
      particles[i].x = particles[i].x + particles[i].vx * dt;
      particles[i].y = particles[i].y + particles[i].vy * dt;
      }
    `;

    // enforce incompressibility by performing double-density relaxation
    const relaxDensityWGSL = `
      struct Params { a : vec4<f32>, b : vec4<f32>, c : vec4<f32> };
      @group(0) @binding(0) var<uniform> params : Params;
  
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read> particles : array<Particle>;
  
      struct Disp { dx : atomic<i32>, dy : atomic<i32> };
      @group(0) @binding(2) var<storage, read_write> disp : array<Disp>;
  
      // truncate float->i32 fixed-point conversion
      fn toFixed(v: f32, scale: f32) -> i32 {
      return i32(v * scale);
      }
  
      // optional clamp helper to avoid insanely large D_term contributions
      fn clampD(v: f32, maxVal: f32) -> f32 {
      return clamp(v, -maxVal, maxVal);
      }
  
      @compute @workgroup_size(256)
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
  
      let px = particles[i].x;
      let py = particles[i].y;
  
      let h = params.b.x;
      let k = params.b.z;
      let k_near = params.b.w;
      let dt_sqr = params.a.w;
      let rho0 = params.b.y;
      let SCALE = params.c.y;
  
      let h2 = h * h;
      // clamp per-pair D_term magnitude to avoid overflow (in world units)
      let maxD = 0.5 * h; // reasonable limit for single-pair D_term
  
      for (var j: u32 = 0u; j < count; j = j + 1u) {
          if (j == i) { continue; }
  
          let qx = particles[j].x;
          let qy = particles[j].y;
  
          let rx = qx - px; // i -> j
          let ry = qy - py;
          let dist2 = rx*rx + ry*ry;
  
          if (dist2 < h2 && dist2 > 1e-10) {
          // use inverseSqrt + multiply to avoid explicit sqrt()
          let invDist = inverseSqrt(dist2);    // 1 / sqrt(dist2)
          let dist = dist2 * invDist;          // sqrt(dist2) == dist2 * (1/sqrt(dist2))
          let q = dist / h;
          let one_minus_q = 1.0 - q;
  
          let density = one_minus_q * one_minus_q;
          let near_density = density * one_minus_q;
  
          let pressure = k * (density - rho0);
          let near_pressure = k_near * near_density;
  
          let D_term = dt_sqr * (pressure * one_minus_q + near_pressure * one_minus_q * one_minus_q);
  
          // clamp the pairwise correction magnitude (safety)
          let D_term_clamped = clampD(D_term, maxD);
  
          let nx = rx * invDist;
          let ny = ry * invDist;
  
          let Dx = nx * D_term_clamped;
          let Dy = ny * D_term_clamped;
  
          let halfDx = 0.5 * Dx;
          let halfDy = 0.5 * Dy;
  
          // convert to fixed-point and atomically add
          atomicAdd(&disp[i].dx, toFixed(-halfDx, SCALE));
          atomicAdd(&disp[i].dy, toFixed(-halfDy, SCALE));
          atomicAdd(&disp[j].dx, toFixed(halfDx, SCALE));
          atomicAdd(&disp[j].dy, toFixed(halfDy, SCALE));
          }
      }
      }
    `;

    // apply displacements: load atomics, convert back to float, apply to particles, clear atomics
    const applyDispWGSL = `
      struct Params { a : vec4<f32>, b : vec4<f32>, c : vec4<f32> };
      @group(0) @binding(0) var<uniform> params : Params;
  
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read_write> particles : array<Particle>;
  
      struct Disp { dx : atomic<i32>, dy : atomic<i32> };
      @group(0) @binding(2) var<storage, read_write> disp : array<Disp>;
  
      fn fromFixed(v: i32, scale: f32) -> f32 {
      return f32(v) / scale;
      }
  
      @compute @workgroup_size(${workgroupSize})
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
  
      let SCALE = params.c.y;
  
      let ix = atomicLoad(&disp[i].dx);
      let iy = atomicLoad(&disp[i].dy);
  
      let fx = fromFixed(ix, SCALE);
      let fy = fromFixed(iy, SCALE);
  
      particles[i].x = particles[i].x + fx;
      particles[i].y = particles[i].y + fy;
  
      // clear for next frame
      atomicStore(&disp[i].dx, 0);
      atomicStore(&disp[i].dy, 0);
      }
    `;

    // boundary pass
    const applyBoundaryWGSL = `
      struct Params { a : vec4<f32>, b : vec4<f32>, c : vec4<f32> };
      @group(0) @binding(0) var<uniform> params : Params;
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read_write> particles : array<Particle>;
  
      @compute @workgroup_size(${workgroupSize})
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
      var px = particles[i].x;
      var py = particles[i].y;
      var vx = particles[i].vx;
      var vy = particles[i].vy;
  
      if (px < -1.0) { px = -1.0; vx = vx; }
      if (px >  1.0) { px =  1.0; vx = vx; }
      if (py < -1.0) { py = -1.0; vy = vy; }
      if (py >  1.0) { py =  1.0; vy = vy; }
  
      particles[i].x = px;
      particles[i].y = py;
      particles[i].vx = vx;
      particles[i].vy = vy;
      }
    `;

    // update velocity from positions
    const updateVelWGSL = `
      struct Params { a : vec4<f32>, b : vec4<f32>, c : vec4<f32> };
      @group(0) @binding(0) var<uniform> params : Params;
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(1) var<storage, read_write> particles : array<Particle>;
  
      @compute @workgroup_size(${workgroupSize})
      fn main(@builtin(global_invocation_id) id : vec3<u32>) {
      let i = id.x;
      let count = u32(params.c.x);
      if (i >= count) { return; }
      let dt = params.a.x;
      let px = particles[i].x;
      let py = particles[i].y;
      let pdx = particles[i].pX;
      let pdy = particles[i].pY;
      particles[i].vx = (px - pdx) / dt;
      particles[i].vy = (py - pdy) / dt;
      }
    `;

    // simple render shaders: use binding 0 for particles (separate layout)
    const vsWGSL = `
      struct Particle { x : f32, y : f32, vx : f32, vy : f32, pX : f32, pY : f32, pad0 : f32, pad1 : f32 };
      @group(0) @binding(0) var<storage, read> particles : array<Particle>;
      struct VSOut { @builtin(position) pos : vec4<f32>, @location(0) color : vec4<f32> };
      @vertex fn vs_main(@builtin(vertex_index) idx : u32) -> VSOut {
      let pIndex = idx / 3u;
      let corner = idx % 3u;
      let px = particles[pIndex].x;
      let py = particles[pIndex].y;
      var offset: vec2<f32>;
      if (corner == 0u) { offset = vec2<f32>(-0.006,  0.006); }
      else if (corner == 1u) { offset = vec2<f32>( 0.006, 0.0); }
      else { offset = vec2<f32>(-0.006, -0.006); }
      var out: VSOut;
      out.pos = vec4<f32>(px + offset.x, py + offset.y, 0.0, 1.0);
      out.color = vec4<f32>(0.2, 0.45, 0.9, 1.0);
      return out;
      }
    `;
    const fsWGSL = `
      @fragment fn fs_main(@location(0) color : vec4<f32>) -> @location(0) vec4<f32> { return color; }
    `;

    // PIPELINES
    function makeCompute(code) {
    return device.createComputePipeline({
        layout: 'auto',
        compute: { module: device.createShaderModule({ code }), entryPoint: 'main' }
    });
    }

    const forcePipeline = makeCompute(applyExtForceWGSL);
    const predPipeline = makeCompute(predPosWGSL);
    const relaxAccumulatePipeline = makeCompute(relaxDensityWGSL);
    const relaxApplyPipeline = makeCompute(applyDispWGSL);
    const boundaryPipeline = makeCompute(applyBoundaryWGSL);
    const velPipeline = makeCompute(updateVelWGSL);

    const renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: device.createShaderModule({ code: vsWGSL }), entryPoint: 'vs_main' },
    fragment: { module: device.createShaderModule({ code: fsWGSL }), entryPoint: 'fs_main', targets: [{ format }] },
    primitive: { topology: 'triangle-list' },
    });

    // BIND GROUPS
    // compute bind groups -> (0) params (uniform), (1) particles (storage), (2) disp (storage - when used)
    const forceBind = device.createBindGroup({
    layout: forcePipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
    ]
    });
    const predBind = device.createBindGroup({
    layout: predPipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
    ]
    });
    const relaxAccBind = device.createBindGroup({
    layout: relaxAccumulatePipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
        { binding: 2, resource: { buffer: dispBuffer } },
    ]
    });
    const relaxApplyBind = device.createBindGroup({
    layout: relaxApplyPipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
        { binding: 2, resource: { buffer: dispBuffer } },
    ]
    });
    const boundaryBind = device.createBindGroup({
    layout: boundaryPipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
    ]
    });
    const velBind = device.createBindGroup({
    layout: velPipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: paramsBuffer } },
        { binding: 1, resource: { buffer: particleBuffer } },
    ]
    });

    // render bind group: vertex uses binding 0 for particles
    const renderBind = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [
        { binding: 0, resource: { buffer: particleBuffer } },
    ]
    });

    // MAIN LOOP
    let frameCount = 0;

    // FPS measurement variables
    let lastTime = performance.now();
    const frameTimes = []; // rolling buffer of last N frame intervals (ms)
    const maxSamples = 60; // smoothing window (60 frames ~= 1s)
    let lastInfoUpdate = 0;

    function measureFPS(now) {
    // now in ms (performance.now)
    const dtMs = now - lastTime;
    // avoid div by zero; clamp dtMs to a small positive number
    const safeDt = dtMs > 0 ? dtMs : 0.0001;
    // push the frame interval
    frameTimes.push(safeDt);
    if (frameTimes.length > maxSamples) frameTimes.shift();
    // compute average ms/frame and average fps
    const sum = frameTimes.reduce((a, b) => a + b, 0);
    const avgMs = sum / frameTimes.length;
    const avgFps = 1000 / avgMs;
    const instFps = 1000 / safeDt;
    lastTime = now;
    return { dtMs: safeDt, instFps, avgFps, avgMs };
    }

    function formatFPS(v) {
    return v.toFixed(1);
    }

    function frame(now) {
    // if called without RAF timestamp, use performance.now()
    now = now === undefined ? performance.now() : now;

    // measure fps (instant + smoothed)
    const fpsInfo = measureFPS(now);

    // keep params up-to-date
    writeParams();

    const encoder = device.createCommandEncoder();

    // 1) apply external force (gravity)
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(forcePipeline);
        pass.setBindGroup(0, forceBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // 2) predict positions (pX/pY = old pos; x += vx*dt, etc.)
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(predPipeline);
        pass.setBindGroup(0, predBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // 3) accumulate symmetric double density relax corrections into disp (atomics)
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(relaxAccumulatePipeline);
        pass.setBindGroup(0, relaxAccBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // 4) apply accumulated displacements and clear accumulators
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(relaxApplyPipeline);
        pass.setBindGroup(0, relaxApplyBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // 5) boundary resolution
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(boundaryPipeline);
        pass.setBindGroup(0, boundaryBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // 6) update velocities from pos difference
    {
        const pass = encoder.beginComputePass();
        pass.setPipeline(velPipeline);
        pass.setBindGroup(0, velBind);
        pass.dispatchWorkgroups(dispatchCount);
        pass.end();
    }

    // Render
    const view = context.getCurrentTexture().createView();
    const rpass = encoder.beginRenderPass({
        colorAttachments: [{
        view,
        clearValue: { r: 0.02, g: 0.02, b: 0.03, a: 1 },
        loadOp: 'clear',
        storeOp: 'store'
        }]
    });
    rpass.setPipeline(renderPipeline);
    rpass.setBindGroup(0, renderBind);
    rpass.draw(particleCount * 3, 1, 0, 0);
    rpass.end();

    device.queue.submit([encoder.finish()]);

    // update info
    frameCount++;

    // update display every 8 frames (same cadence you had), include fps
    if ((frameCount & 7) === 0) {
        // fpsInfo contains instFps and avgFps
        const inst = formatFPS(fpsInfo.instFps);
        const avg = formatFPS(fpsInfo.avgFps);
        // show ms/frame too (smoothed)
        const avgMs = fpsInfo.avgMs.toFixed(2);
        infoEl.textContent = `COMPUTE FLUID | frames: ${frameCount}  |  FPS:  ${avgMs} ms/frame | Leke Ayeko`;
    }

    requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
</script>
</body>
</html>
